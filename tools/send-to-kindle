#!/usr/bin/env python3
"""Fetch an article with a real browser, clean it, and email it to Kindle."""

import sys
import os
import json
import subprocess
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import re

from playwright.sync_api import sync_playwright
from readability import Document
from bs4 import BeautifulSoup


ENV_PATH = os.path.expanduser("~/.openclaw/.env")

DISMISS_SELECTORS = [
    "button:has-text('Accept')",
    "button:has-text('Accept All')",
    "button:has-text('Accept Cookies')",
    "button:has-text('Agree')",
    "button:has-text('I Agree')",
    "button:has-text('OK')",
    "button:has-text('Got it')",
    "button:has-text('Continue')",
    "button:has-text('Allow')",
    "[aria-label='Close']",
    "[aria-label='Dismiss']",
    "[aria-label='close']",
    "button.close",
    ".modal-close",
    ".popup-close",
    "button:has-text('Reject All')",
    "button:has-text('Reject')",
    "#onetrust-accept-btn-handler",
    ".fc-cta-consent",
]


def load_env():
    config = {}
    with open(ENV_PATH) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            if "=" in line:
                key, val = line.split("=", 1)
                config[key.strip()] = val.strip().strip('"')
    return config


def dismiss_popups(page):
    for selector in DISMISS_SELECTORS:
        try:
            btn = page.locator(selector).first
            if btn.is_visible(timeout=500):
                btn.click(timeout=2000)
                page.wait_for_timeout(500)
                return
        except Exception:
            continue


def page_is_blocked(page):
    """Detect CAPTCHA, empty pages, or bot walls."""
    body_text = page.locator("body").inner_text().strip()
    # Empty body or very short = likely blocked
    if len(body_text) < 200:
        return True
    # CAPTCHA iframes
    for frame in page.frames:
        if "captcha" in frame.url.lower():
            return True
    return False


def fetch_with_browser(url):
    """Open a real Chrome window, load the page, grab content."""
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False)
        page = browser.new_page()
        page.goto(url, wait_until="domcontentloaded", timeout=30000)
        # Wait for content to appear, checking at intervals
        for _ in range(6):
            page.wait_for_timeout(2000)
            if not page_is_blocked(page):
                break
        dismiss_popups(page)
        page.wait_for_timeout(1000)
        blocked = page_is_blocked(page)
        html = page.content()
        browser.close()
    return html, blocked


def extract_title(html, readability_title):
    soup = BeautifulSoup(html, "lxml")
    og = soup.find("meta", property="og:title")
    if og and og.get("content", "").strip():
        return og["content"].strip()
    h1 = soup.find("h1")
    if h1 and h1.get_text(strip=True):
        return h1.get_text(strip=True)
    if readability_title and "." not in readability_title:
        return readability_title
    tag = soup.find("title")
    if tag and tag.string:
        t = tag.string.strip()
        t = re.split(r"\s*[|\-–—]\s*", t)[0].strip()
        if t:
            return t
    return readability_title or "Article"


def extract_content(html):
    doc = Document(html)
    raw_title = doc.title()
    title = extract_title(html, raw_title)
    content_html = doc.summary()
    return title, content_html


def clean_html(html):
    soup = BeautifulSoup(html, "lxml")
    for tag in soup.find_all(["script", "style", "nav", "iframe", "form", "button"]):
        tag.decompose()
    for tag in soup.find_all(attrs={"class": re.compile(r"ad|sidebar|popup|modal|banner", re.I)}):
        tag.decompose()
    for tag in soup.find_all(attrs={"id": re.compile(r"ad|sidebar|popup|modal|banner", re.I)}):
        tag.decompose()
    return str(soup)


def generate_summary(html_content):
    """Generate an AI summary of article content using Claude via openclaw."""
    try:
        soup = BeautifulSoup(html_content, "lxml")
        text = soup.get_text(separator=" ", strip=True)
        if not text or len(text) < 200:
            return None

        word_count = len(text.split())
        if word_count < 1000:
            par_hint = "1 short paragraph"
        elif word_count < 3000:
            par_hint = "2 paragraphs"
        elif word_count < 6000:
            par_hint = "3 paragraphs"
        else:
            par_hint = "4 paragraphs"

        prompt = (
            f"Write a {par_hint} summary of the following article. Be concise and informative. "
            "Focus on the key points and takeaways. No preamble like 'This article discusses' "
            "— go straight into the substance. Return ONLY the summary text, no markdown formatting.\n\n"
            f"Article:\n{text[:12000]}"
        )

        result = subprocess.run(
            ['openclaw', 'agent', '--agent', 'worker',
             '--message', prompt, '--json', '--thinking', 'off'],
            capture_output=True, text=True, timeout=60
        )

        if result.returncode != 0:
            print(f"Warning: summary agent error: {result.stderr}", file=sys.stderr)
            return None

        response_data = json.loads(result.stdout)
        payloads = response_data.get('result', {}).get('payloads', [])
        if not payloads:
            return None

        summary = payloads[0].get('text', '').strip()
        if not summary:
            return None

        # Convert to HTML paragraphs
        paragraphs = [p.strip() for p in summary.split("\n\n") if p.strip()]
        if not paragraphs:
            paragraphs = [p.strip() for p in summary.split("\n") if p.strip()]
        return "\n".join(f"<p>{p}</p>" for p in paragraphs)
    except Exception as e:
        print(f"Warning: summary generation failed: {e}", file=sys.stderr)
        return None


def format_kindle_html(title, content, summary=None):
    summary_block = ""
    if summary:
        summary_block = f"""<div style="background-color: #f0f0f0; border-left: 4px solid #333; padding: 15px 20px; margin-bottom: 1.5em;">
<h2 style="margin-top: 0; font-size: 1.1em; text-transform: uppercase; letter-spacing: 0.05em;">AI Summary</h2>
{summary}
</div>
<hr style="border: none; border-top: 1px solid #ddd; margin: 1.5em 0;">"""
    return f"""<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>{title}</title>
<style>
body {{
    font-family: Georgia, "Times New Roman", serif;
    line-height: 1.6;
    max-width: 600px;
    margin: 0 auto;
    padding: 20px;
    color: #1a1a1a;
}}
h1 {{
    font-size: 1.5em;
    margin-bottom: 0.5em;
    line-height: 1.3;
}}
img {{
    max-width: 100%;
    height: auto;
}}
p {{
    margin-bottom: 1em;
}}
blockquote {{
    border-left: 3px solid #ccc;
    padding-left: 1em;
    margin-left: 0;
    color: #444;
}}
</style>
</head>
<body>
<h1>{title}</h1>
{summary_block}
{content}
</body>
</html>"""


def clean_filename(text):
    """Keep the title readable — just strip characters that aren't safe in filenames."""
    text = re.sub(r'[<>:"/\\|?*]', '', text).strip()
    return text[:100] or "Article"


def send_email(config, title, html_body):
    msg = MIMEMultipart()
    msg["From"] = config["SMTP_USER"]
    msg["To"] = config["KINDLE_EMAIL"]
    msg["Subject"] = title

    msg.attach(MIMEText("Article attached.", "plain"))

    attachment = MIMEBase("text", "html")
    attachment.set_payload(html_body.encode("utf-8"))
    encoders.encode_base64(attachment)
    filename = clean_filename(title) + ".html"
    attachment.add_header("Content-Disposition", "attachment", filename=filename)
    msg.attach(attachment)

    with smtplib.SMTP(config["SMTP_HOST"], int(config["SMTP_PORT"])) as server:
        server.starttls()
        server.login(config["SMTP_USER"], config["SMTP_PASS"])
        server.send_message(msg)


def main():
    if len(sys.argv) < 2:
        print("Usage: send-to-kindle <url>", file=sys.stderr)
        sys.exit(1)

    url = sys.argv[1]
    config = load_env()

    for key in ("SMTP_HOST", "SMTP_PORT", "SMTP_USER", "SMTP_PASS", "KINDLE_EMAIL"):
        if key not in config:
            print(f"Missing {key} in {ENV_PATH}", file=sys.stderr)
            sys.exit(1)

    raw_html, blocked = fetch_with_browser(url)

    if blocked:
        print(f"BLOCKED: Page content looks empty — may need manual interaction.", file=sys.stderr)
        print(f"Try with Playwright headed mode, dismiss blockers, and grab the content.", file=sys.stderr)
        sys.exit(1)

    title, content = extract_content(raw_html)
    cleaned = clean_html(content)
    summary = generate_summary(cleaned)
    kindle_html = format_kindle_html(title, cleaned, summary=summary)

    send_email(config, title, kindle_html)
    print(f"Sent to Kindle: {title}")


if __name__ == "__main__":
    main()
